Management of MSs:
    - Too many services, too small service or too big services

Monitoring & Logging: 
    - very important to avoid failures. Keep track user e2e activity using Disctributed Tracing
    - Kibana, Prometheus

Service Discovery: - to trasnlate service to IP/host for 100s of services. 
    - Use Service Registry (Consul by Hashicorp, Eureka, apache Zookeeper)--- https://howtodoinjava.com/spring-cloud/consul-service-registration-discovery/ , https://cloud.spring.io/spring-cloud-consul/1.3.x/single/spring-cloud-consul.html
    - Consul - Great service discovery infrastructure
    - Eureka - Easy setup and integration with spring-cloud
    - Consul and Eureka are both open source tools
    - LB based discovery
    - Service mesh

Proper Authentication & Authourization: - For user to service and service to service communication.
    - client_credentials or user auth
    - JWT, Oauth2

Config Management: - passwords, keys, tokens
    - Use a central config service [Scalable, Robust, Fault Tolerant] 
    - Use a DB

Fault Tolerance:
    - Make sure no failures/outages
    - Have backups or multiple instances
    - Avoid cascading failures
    - Use circuit breaker pattern so that fauly service request could be automatically rerouted

Integration Testing:
    - Diffcult to spin up all service to achive Integration Test environment

Dependency Management:
    - Services should be loosely coupled
    - Ensure proper versioning of libs
    - Ensure backword compatibility of libs
    - Ensure proper versioning of Data
    - Ensure backword compatibility of Data

Stateless vs Stateful:
    - Stateless service will not store any data in server. Ex - A ACID is going on in server/service A, service goes down. If service was storing any data locally then other server can not resume a task, that data is lost in case of stateful. So stateless is more scalable and fault tolerant.

Idempotency for APIs:
    - except POST all are indempotense by nature.
    - Post always creates the object/entity
    - Issues occurs when duplicate request comes from client. Could be due to parallelisation or retry due to timeout or other issues. A duplicate request could also go to different API instances.
    - How to handle?
        - Use UUID - https://www.baeldung.com/java-uuid
        - https://stripe.com/docs/api/idempotent_requests?lang=java
        